# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'e:\video\DouYin_spider\DY.ui'
#
# Created by: PyQt5 UI code generator 5.15.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import *
from PyQt5.QtCore import Qt
import os, sys, requests
import json, re, time
import random
from retrying import retry
from contextlib import closing
from threading import Thread
from PyQt5.QtCore import QCoreApplication,pyqtSignal, QThread
exist_num=0
download_num=0
total_num=0
save_dir ='./Download/'
type_flag = 'p'
watermark_flag=0
USER_ITEM = {}
def num_change(num):
    num=int(num)
    if num>=10e5:
        ten_thousand=int(num/10000)
        thousand=int((num%10000)/1000)
        return f'{ten_thousand}.{thousand}w'
    elif num>=10e3:
        thousand=int(num/1000)
        hundred=int((num%1000)/100)
        return f'{thousand}.{hundred}k'
    else:
        return str(num)
def sec_name(mstr):
    import re
    rstr = r"[\/\\\:\*\?\"\<\>\|]" # '/ \ : * ? " < > |'
    string = re.sub(rstr, "", mstr)
    return string
def strict_name(mstr):
    string =re.sub(u"([^\u4e00-\u9fa5\u0030-\u0039\u0041-\u005a\u0061-\u007a\/\\])","",mstr)  
    return string
def clear():
    if os.name=='nt':
        y=os.system('cls')
    else:
        y=os.system('clear')
def timechange(timeStamp):
    timeArray = time.localtime(timeStamp)
    otherStyleTime = time.strftime("%Y-%m-%d_%H-%M-%S", timeArray)
    #print(otherStyleTime)   # 2013--10--10 23:40:00
    return otherStyleTime
def get_sec_uid(url):
    headers = {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36'}
    # 请求网页
    response = requests.get(url, headers=headers)
    #print(response.status_code)  # 打印响应的状态码
    real_url=response.url
    sec_uid=real_url.split("sec_uid=")[1].split("&")[0]
    return sec_uid
def getjsonfilelist(name=None):
    filePath = './json/'
    filelist=os.listdir(filePath)
    #print(filelist)
    jsonlist=[]
    for file in filelist:
        if name!=None:
            if ('.json' in file) and (name in file):
                jsonlist.append(file)
        else:
            if ('.json' in file):
                jsonlist.append(file)
    return jsonlist
def getauthor(jsonlist):
    author_list=[]
    for jsonfile in jsonlist:
        with open(f'./json/{jsonfile}','r', encoding='UTF-8') as file:
            jsontemp=json.load(file,strict=False)
            author_list.append({
                'sec_uid': re.sub(r'[\/:*?"<>|]', '', jsontemp['sec_uid']) if jsontemp['sec_uid'] else None,
                'nickname': jsontemp['作者']
            })
    return author_list

class spider_dy():
    def __init__(self,sec_uid,):
        self.sec_uid=sec_uid
        self.headers = {
            'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9',
            'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8',
            'pragma': 'no-cache',
            'cache-control': 'no-cache',
            'upgrade-insecure-requests': '1',
            'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1',
        }
    def get_video_urls(self, sec_uid, type_flag='p'):
        '''
        Get the video link of user
        :param type_flag: the type of video
        :return: nickname, video_list
        '''
        user_url_prefix = 'https://www.amemv.com/web/api/v2/aweme/post' if type_flag == 'p' else 'https://www.iesdouyin.com/web/api/v2/aweme/like'
        item_url='https://www.iesdouyin.com/web/api/v2/aweme/iteminfo/?item_ids='
        userinfo_url='https://www.amemv.com/web/api/v2/user/info/?uid='
        print('---解析视频链接中...\r')
        i = 0
        result = []
        max_cursor=0
        has_more=True
        while has_more :
            i = i + 1
            print('---正在第 {} 次尝试...\r'.format(str(i)))
            user_url = user_url_prefix + f'/?sec_uid={sec_uid}&count=2000&max_cursor={max_cursor}' 
            response = self.get_request(user_url)
            html = json.loads(response.content.decode())
            has_more,max_cursor=html['has_more'],html['max_cursor']
            if html['aweme_list'] != []:
                result += html['aweme_list']
      
        nickname = None
        video_list = []
        author={}
        i=0
        uid=result[0]['author']['uid']
        u_url =userinfo_url+str(uid)
        response = self.get_request(u_url)
        resp_json= json.loads(response.content.decode())
        author['作者'] = resp_json['user_info']['nickname'].replace('\n', ',').replace(' ', '')
        author['粉丝'] = num_change(resp_json['user_info']['follower_count'])
        author['获赞'] = num_change(resp_json['user_info']['total_favorited'])
        author['简介'] = resp_json['user_info']['signature'].replace('\n', ',').replace(' ', '')
        author['抖音号'] = resp_json['user_info']['unique_id']
        author['作品数'] = resp_json['user_info']['aweme_count']
        author['喜欢作品'] = resp_json['user_info']['favoriting_count']
        author['user_id'] = resp_json['user_info']['uid']
        author['关注'] = resp_json['user_info']['following_count']
        author['sec_uid'] = result[0]['author']['sec_uid']
        for item in result:  
            if nickname is None:
                nickname = item['author']['nickname'] if re.sub(r'[\/:*?"<>|]', '', item['author']['nickname']) else None
            datetime=timechange(int(item['video']['origin_cover']['uri'].split("_")[-1])) if len(item['video']['origin_cover']['uri'].split("_"))>1 else None
            if datetime==None:
                aweme_id=item['statistics']['aweme_id']
                v_url =item_url+str(aweme_id)
                response = self.get_request(v_url)
                html = json.loads(response.content.decode())
                datetime=timechange(int(html['item_list'][0]['create_time']))
            
            url=item['video']['play_addr']['url_list']
            video_list.append({
                'desc': re.sub(r'[\/:*?"<>|]', '', item['desc']) if item['desc'] else nickname,
                'url': url,
                'time':datetime
            })
        author['video']=video_list
        with open(f"./json/{nickname}.json","w",encoding='utf-8') as f:
            json.dump(author,f,ensure_ascii=False,indent=4)
        del author['video']
        del author['sec_uid']
        return nickname, video_list,author  
    def get_download_url(self, video_url, watermark_flag):
        '''
        Whether to download watermarked videos
        :param video_url: the url of video
        :param watermark_flag: the type of video
        :return: the url of o
        '''
        if watermark_flag == True:
            download_url = video_url.replace('api.amemv.com', 'aweme.snssdk.com')
        else:
            download_url = video_url.replace('aweme.snssdk.com', 'api.amemv.com')

        return download_url
    def video_downloader(self, video_url, video_name, watermark_flag=False):
        '''
        Download the video
        :param video_url: the url of video
        :param video_name: the name of video
        :param watermark_flag: the flag of video
        :return: None
        '''
        size = 0
        video_url = self.get_download_url(video_url, watermark_flag=watermark_flag)
        with closing(requests.get(video_url, headers=self.headers, stream=True)) as response:
            chunk_size = 1024
            content_size = int(response.headers['content-length'])
            if response.status_code == 200:
                filesize=content_size / chunk_size / 1024
                if filesize==0:
                    return 0
                sys.stdout.write('----[文件大小]:%0.2f MB\n' % filesize)
                try:
                    with open(video_name + '.mp4', 'wb') as file:
                        for data in response.iter_content(chunk_size=chunk_size):
                            file.write(data)
                            size += len(data)
                            file.flush()

                            sys.stdout.write('----[下载进度]:%.2f%%' % float(size / content_size * 100) + '\r')
                            sys.stdout.flush()
                except: 
                    videoname=strict_name(video_name)
                    with open(video_name + '.mp4', 'wb') as file:
                        for data in response.iter_content(chunk_size=chunk_size):
                            file.write(data)
                            size += len(data)
                            file.flush()

                            sys.stdout.write('----[下载进度]:%.2f%%' % float(size / content_size * 100) + '\r')
                            sys.stdout.flush()
                return 1     
            else:
                return 0
    @retry(stop_max_attempt_number=3)
    def get_request(self, url, params=None):
        '''
        Send a get request
        :param url: the url of request
        :param params: the params of request
        :return: the result of request
        '''
        if params is None:
            params = {}
        response = requests.get(url, params=params, headers=self.headers, timeout=10)
        assert response.status_code == 200
        return response

    @retry(stop_max_attempt_number=3)
    def post_request(self, url, data=None):
        '''
        Send a post request
        :param url: the url of request
        :param data: the params of request
        :return: the result of request
        '''
        if data is None:
            data = {}
        response = requests.post(url, data=data, headers=self.headers, timeout=10)
        assert response.status_code == 200
        return response  
    def run(self):
        sec_uid=self.sec_uid
        global USER_ITEM
        global total_num
        global watermark_flag
        nickname, video_list,USER_ITEM = self.get_video_urls(sec_uid,'p')
        total_num=len(video_list)
        nickname_dir = os.path.join(save_dir, nickname)
        if not os.path.exists(nickname_dir):
            os.makedirs(nickname_dir)
        global exist_num
        global download_num 
        if type_flag == 'f':
            if 'favorite' not in os.listdir(nickname_dir):
                os.mkdir(os.path.join(nickname_dir, 'favorite'))

        for num in range(len(video_list)):
            print('---正在解析第%d个视频链接 [%s] 中，请稍后...\n' % (num + 1, video_list[num]['desc']))
            
            title=video_list[num]['time']+sec_name(video_list[num]['desc']) if video_list[num]['time']!=None else video_list[num]['desc']
            video_path = os.path.join(nickname_dir,title ) if type_flag != 'f' else os.path.join(nickname_dir, 'favorite', video_list[num]['desc'])
            if  os.path.exists(video_path+'.mp4'):
                exist_num+=1
                print('---视频已存在...\r\n')
                continue
            else:
                for url in video_list[num]['url']:
                    succeed=self.video_downloader(url, video_path, watermark_flag)
                    if succeed:
                        download_num+=1
                        break
            print('\n')
        print('---下载完成...\r\n')
class Runthread(QThread):
    #  通过类成员对象定义信号对象
    signal = pyqtSignal(str)
    def __init__(self,sec_uid,textBrowser):
        super(Runthread, self).__init__()
        self.sec_uid = sec_uid
        self.textBrowser = textBrowser
    def __del__(self):
        self.wait()
    def run(self):
        try:
            self.list_flag = []
            def start_spider(signal,list_flag):
                # 进度条设置进度
                j=0
                for i in range(10000):
                    j+=random.randint(1,3)
                    signal.emit(str(j))
                    time.sleep(2)
                    if len(list_flag) == 1:

                        break
                    # 注意这里与_signal = pyqtSignal(str)中的类型相同      
            # 开启线程并启动
            t1= Thread(target=start_spider,args=(self.signal,self.list_flag), name='t1')
            t1.start()
            spider_DY = spider_dy(self.sec_uid)
            spider_DY.run()
            # 模拟耗时操作
            # sleep(40)
            self.list_flag.append(0)
            self.signal.emit('ok')
        except Exception as e:
            print(e)
            self.reviewEdit.setText('下载出错:',e)
class MyMainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.author_list=[]
        self.sec_uid=None
        self.thread=None
        self.pushButton.clicked.connect(self.download)
        self.checkBox.stateChanged.connect(self.changecb1)
        self.checkBox_2.stateChanged.connect(self.changecb1)
    def setupUi(self, MainWindow):
        
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(590, 500)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.lineEdit = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit.setGeometry(QtCore.QRect(20, 10, 391, 41))
        self.lineEdit.setObjectName("lineEdit")
        self.lineEdit.setPlaceholderText('请输入抖音用户分享链接,不输入将更新下框选中用户视频')
        self.comboBox = QtWidgets.QComboBox(self.centralwidget)
        self.comboBox.setGeometry(QtCore.QRect(20, 110, 361, 51))
        self.comboBox.setObjectName("comboBox")
        self.textBrowser = QtWidgets.QTextBrowser(self.centralwidget)
        self.textBrowser.setGeometry(QtCore.QRect(20, 230, 531, 241))
        self.textBrowser.setObjectName("textBrowser")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(440, 10, 101, 41))
        self.pushButton.setObjectName("pushButton")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(-10, 70, 381, 16))
        self.label.setObjectName("label")
        self.pro_bar = QtWidgets.QProgressBar(self.centralwidget)
        self.pro_bar.setGeometry(QtCore.QRect(20, 190, 541, 23))
        self.pro_bar.setProperty("value", 0)
        self.pro_bar.setObjectName("progressBar")
        self.label_2 = QtWidgets.QLabel(self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(80, 170, 121, 16))
        self.label_2.setObjectName("label_2")
        self.checkBox = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox.setGeometry(QtCore.QRect(390, 100, 81, 19))
        self.checkBox.setObjectName("checkBox")
        self.checkBox.setChecked(True)
        self.checkBox_2 = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_2.setGeometry(QtCore.QRect(500, 100, 81, 19))
        self.checkBox_2.setObjectName("checkBox_2")
        self.checkBox_2.setChecked(False)
        self.lineEdit_2 = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_2.setGeometry(QtCore.QRect(388, 135, 200, 21))
        self.lineEdit_2.setText("")
        self.lineEdit_2.setObjectName("lineEdit_2")
        self.lineEdit_2.setPlaceholderText('保存路径 默认./Download/ ')
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "抖音视频下载"))
        self.pushButton.setText(_translate("MainWindow", "开始下载"))
        self.label.setText(_translate("MainWindow", "       本地已有信息的用户如下"))
        self.label_2.setText(_translate("MainWindow", "下载进度条"))
        self.checkBox.setText(_translate("MainWindow", "去水印"))
        self.checkBox_2.setText(_translate("MainWindow", "带水印"))
       

    def run(self):
        '''
        Program entry
        '''
        file_list=getjsonfilelist()
        self.author_list=getauthor(file_list)
        name_list=[]
        if self.author_list!=None and len(self.author_list)>0:
            author_num=1
            self.textBrowser.append('己有本地信息的主播如下:\n')
            for author in self.author_list:
                name=author['nickname']
                name_list.append(f'{author_num}-{name}')
                self.textBrowser.append(f'{author_num}-{name}')
                author_num+=1
            self.comboBox.addItems(name_list)
        else:
            self.comboBox.addItems(['本地暂无主播信息，请在上框输入分享链接添加'])
    def changecb1(self):
        if self.checkBox_2.checkState() == Qt.Checked:
            self.checkBox.setChecked(False)
            global watermark_flag
            watermark_flag=1
        else:
            self.checkBox_2.setChecked(False)
    def call_backlog(self, msg):
        # 将线程的参数传入进度条以及显示框
        
        # 达到满进度时设置下载按钮状态
        if msg == 'ok':
            del self.thread
            self.textBrowser.clear()
            self.pro_bar.setValue(100)
            self.textBrowser.append('<h3>---下载完成---</h3>\n')
            self.textBrowser.append(f'<h4>总文件量:{total_num}</h4>\n')
            self.textBrowser.append(f'<h4>下载量:{download_num}</h4>\n')
            self.pushButton.disconnect()
            self.pushButton.clicked.connect(QCoreApplication.quit)
            self.pushButton.setEnabled(True)
            self.pushButton.setText('完成')
            self.textBrowser.append('<h3>---用户信息如下---</h3>\n')
            for name,value in USER_ITEM.items():
                self.textBrowser.append(f'<h4>{name}:{str(value)}</h4>\n')
        else:
            self.textBrowser.clear()
            self.pro_bar.setValue(int(msg))
            self.textBrowser.append(f'下载中,进度:{msg}')
            self.cursor = self.textBrowser.textCursor()
            self.textBrowser.moveCursor(self.cursor.End)
    def download(self):
        self.pushButton.setEnabled(False)
        self.textBrowser.clear()
        global save_dir
        if self.lineEdit_2.text():
            save_dir=self.lineEdit_2.text()
        if self.lineEdit.text():
            try:
                share_url=re.findall(r'(https?://[^\s]+)', str(self.lineEdit.text()))[0]
                sec_uid = get_sec_uid(share_url)
                sec_uid = sec_uid if sec_uid else 'MS4wLjABAAAAle_oORaZCgYlB84cLTKSqRFvDgGmgrJsS6n3TfwxonM'
                self.pushButton.setText('下载中')
                self.thread = Runthread(sec_uid,self.textBrowser)
                self.thread.signal.connect(self.call_backlog)  # 进程连接回传到GUI的事件
                self.thread.start()
            except:
                raise ValueError("输入必须是url链接")
                set_text = '链接不正确，请重新输入或换一个链接'
                self.textBrowser.setText(set_text)
                self.download_Button.setEnabled(True)
        else:
            no=self.comboBox.currentIndex()
            sec_uid=self.author_list[no]['sec_uid']
            sec_uid = sec_uid if sec_uid else 'MS4wLjABAAAAle_oORaZCgYlB84cLTKSqRFvDgGmgrJsS6n3TfwxonM'
            self.pushButton.setText('下载中')
            self.thread = Runthread(sec_uid,self.textBrowser)
            self.thread.signal.connect(self.call_backlog)  # 进程连接回传到GUI的事件
            self.thread.start()

        

if __name__ =='__main__':
    app = QApplication(sys.argv)
    myWin = MyMainWindow()
    myWin.show()
    myWin.run()
    sys.exit(app.exec_())
